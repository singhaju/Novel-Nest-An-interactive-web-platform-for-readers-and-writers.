// Prisma schema for Novel Nest with MySQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
  READER
  WRITER
  ADMIN
  DEVELOPER
}

enum NovelStatus {
  ONGOING
  COMPLETED
  HIATUS
  PENDING_APPROVAL
}

// Users table
model User {
  user_id         Int      @id @default(autoincrement())
  username        String   @unique
  email           String   @unique
  password        String   // Hashed password
  profile_picture String?  // Google Drive URL
  bio             String?  @db.Text
  role            UserRole @default(READER)
  created_at      DateTime @default(now())

  // Relations
  novels                Novel[]              @relation("NovelAuthor")
  reviews               Review[]
  comments              Comment[]
  wishlists             UserWishlist[]
  following             UserFollow[]         @relation("Follower")
  followers             UserFollow[]         @relation("Following")
  readingProgress       UserReadingProgress[]
  novelAuthors          NovelAuthor[]
  likes                 NovelLike[]

  @@map("users")
}

// Novels table
model Novel {
  novel_id    Int          @id @default(autoincrement())
  title       String
  description String?      @db.Text
  cover_image String?      // Google Drive URL
  tags        String?      @db.Text // JSON array stored as text
  status      NovelStatus  @default(PENDING_APPROVAL)
  last_update DateTime     @updatedAt
  views       Int          @default(0)
  likes       Int          @default(0)
  rating      Decimal      @default(0.00) @db.Decimal(3, 2)
  created_at  DateTime     @default(now())

  // Relations
  author      User         @relation("NovelAuthor", fields: [author_id], references: [user_id], onDelete: Cascade)
  author_id   Int
  episodes    Episode[]
  reviews     Review[]
  wishlists   UserWishlist[]
  readingProgress UserReadingProgress[]
  novelAuthors NovelAuthor[]
  likedBy     NovelLike[]

  @@index([author_id])
  @@index([status])
  @@map("novels")
}

// Episodes table
model Episode {
  episode_id   Int      @id @default(autoincrement())
  novel_id     Int
  title        String
  content      String   @db.Text // Google Drive URL to document
  release_date DateTime @default(now())

  // Relations
  novel        Novel    @relation(fields: [novel_id], references: [novel_id], onDelete: Cascade)
  comments     Comment[]

  @@index([novel_id])
  @@map("episodes")
}

// Reviews table
model Review {
  review_id  Int      @id @default(autoincrement())
  novel_id   Int
  user_id    Int
  rating     Int      // 1-5 stars
  comment    String?  @db.Text
  created_at DateTime @default(now())

  // Relations
  novel      Novel    @relation(fields: [novel_id], references: [novel_id], onDelete: Cascade)
  user       User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([novel_id])
  @@index([user_id])
  @@map("reviews")
}

// Comments table
model Comment {
  comment_id        Int      @id @default(autoincrement())
  episode_id        Int
  user_id           Int
  parent_comment_id Int?
  content           String   @db.Text
  created_at        DateTime @default(now())

  // Relations
  episode           Episode  @relation(fields: [episode_id], references: [episode_id], onDelete: Cascade)
  user              User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  parent            Comment? @relation("CommentReplies", fields: [parent_comment_id], references: [comment_id], onDelete: Cascade)
  replies           Comment[] @relation("CommentReplies")

  @@index([episode_id])
  @@index([user_id])
  @@index([parent_comment_id])
  @@map("comments")
}

// Novel Authors (Bridge Table for co-authorship)
model NovelAuthor {
  user_id     Int
  novel_id    Int
  author_role String   @default("Author")

  // Relations
  user        User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  novel       Novel    @relation(fields: [novel_id], references: [novel_id], onDelete: Cascade)

  @@id([user_id, novel_id])
  @@map("novel_authors")
}

// User Wishlist (Bridge Table)
model UserWishlist {
  user_id  Int
  novel_id Int
  added_at DateTime @default(now())

  // Relations
  user     User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  novel    Novel    @relation(fields: [novel_id], references: [novel_id], onDelete: Cascade)

  @@id([user_id, novel_id])
  @@map("user_wishlist")
}

// User Follows (Bridge Table)
model UserFollow {
  follower_id  Int
  following_id Int
  followed_at  DateTime @default(now())

  // Relations
  follower     User     @relation("Follower", fields: [follower_id], references: [user_id], onDelete: Cascade)
  following    User     @relation("Following", fields: [following_id], references: [user_id], onDelete: Cascade)

  @@id([follower_id, following_id])
  @@map("user_follows")
}

// User Reading Progress (Bridge Table)
model UserReadingProgress {
  user_id              Int
  novel_id             Int
  last_read_episode_id Int
  updated_at           DateTime @updatedAt

  // Relations
  user                 User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  novel                Novel    @relation(fields: [novel_id], references: [novel_id], onDelete: Cascade)

  @@id([user_id, novel_id])
  @@map("user_reading_progress")
}

// Novel Likes (Bridge Table)
model NovelLike {
  user_id  Int
  novel_id Int

  user  User  @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  novel Novel @relation(fields: [novel_id], references: [novel_id], onDelete: Cascade)

  @@id([user_id, novel_id])
  @@map("novel_likes")
}
